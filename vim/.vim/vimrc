" Based on
" https://raw.githubusercontent.com/nickjj/dotfiles/master/.vimrc
" https://github.com/wincent/wincent/tree/aa3a322e3a911dabe0ef398ebb1fd7c77209b8ac/roles/dotfiles/files/.vim
"
" My Help {{{
"
" VIM & VIEW
" L-ve  - "Vim Edit vimrc"          // :edit $MYVIMRC
" L-vr  - "Vim Runtime vimrc"       // :source $MYVIMRC
" L-vi  - "Vim Install plugins"     // :PlugInstall
" L-vu  - "Vim Update plugins"      // :PlugUpdate
"
" L-vb  - "View Blame"              // :Gblame
" L-vd  - "View Diff split"         // :Gdiffsplit
" L-vD  - "View Difftool"           // :Git difftool
" L-vg  - "View Git window"         // :Git

" OPTIONS TOGGLES
" L-os  - "Option Spell"            // :setlocal spell!
" L-or  - "Option Relative numbers" // :setlocal relativenumber!
" L-ol  - "Option List mode"        // :setlocal list!
" L-ow  - "Option Wrap"             // :setlocal nowrap!

" EDIT
" L-w   - "Write"                   // :write
" K     - "K-Up move"    visual     // :visual
" J     - "J-Down move"  visual     // :visual
" jj    - STOP   insert & command   // <esc>
"
" FIND
" L-ff  - "Find File"               // :FZF
" L-fd  - "Find Directory"          // :Fern
" L-fs  - "Find Symbol"             // :Vista
" L-gd  - "Go to Definition"
" L-gr  - "Go to References"
" L-gR  - "Go to References last"
"

" NAVIGATION & WINDOWS
" C-hjkl- move to window            // C-wC-h...

" L-L   - previous buffer           // C-^
" L-/   - clear search highlight    // :noh
" L-;   - command line              // :
" jk/kj - exit insert / command mode// <C-c>

" L-oO  - "Only One window"         // :only
" L-oo  - "Only one maximized"      // :MaximizerToggle!

" L-qq  - "Quit window"             // :quit
" L-qw  - "Quit and Write"          // :wq
" L-qb  - "Quit Buffer"             // :bdelete
" L-qc  - "Quit c quickfix"         // :cclose
" L-ql  - "Quit l location list"    // :lclose
" L-qp  - "Quit p preview window"   // :pclose
" L-qa  - "Quit All"                // :qall
" L-qe  - "Quit & Exit"             // :qall!

" L-c   - "c quickfix toggle"
" L-l   - "i location list toggle"
"
" }}}

if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  source $MYVIMRC | PlugInstall --sync
  " autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif


" Plugins
" ---------------------

" Specify a directory for plugins.
call plug#begin('~/.vim/plugged')

" Atom One Dark / Light theme.
" Plug 'rakr/vim-one'

" Gruvbox Community theme (morhetz/gruvbox).
Plug 'morhetz/gruvbox'
" Plug 'gruvbox-community/gruvbox'
" Plug 'cormacrelf/vim-colors-github'
" Plug 'freeo/vim-kalisi'
" Plug 'sonph/onehalf', { 'rtp': 'vim' }
" Plug 'chriskempson/base16-vim'
" Plug 'rakr/vim-one'
Plug 'altercation/vim-colors-solarized'
" Plug 'rainglow/vim'
" Plug 'swalladge/paper.vim'
Plug 'humanoid-colors/vim-humanoid-colorscheme'
" Plug 'rakr/vim-two-firewatch'

" Jump to any location specified by two characters.
Plug 'justinmk/vim-sneak'
" Plug 'https://gitlab.com/protesilaos/tempus-themes-vim.git'

" Integrate fzf with Vim.
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'

" Search and edit tool.
Plug 'dyng/ctrlsf.vim'

Plug 'szw/vim-maximizer'

" Better manage Vim sessions.
" Plug 'tpope/vim-obsession'

" Zoom in and out of a specific split pane (similar to tmux).
" Plug 'dhruvasagar/vim-zoom'

" Pass focus events from tmux to Vim (useful for autoread and
" linting tools).
" Plug 'tmux-plugins/vim-tmux-focus-events'

" Navigate and manipulate files in a tree view.
Plug 'lambdalisue/fern.vim'
 
" Plug 'lambdalisue/fern-mapping-mark-children.vim'
Plug 'lambdalisue/nerdfont.vim'
Plug 'lambdalisue/fern-renderer-nerdfont.vim'

" Helpers for moving and manipulating files / directories.
" Plug 'tpope/vim-eunuch'

" Run a diff on 2 directories.
" Plug 'will133/vim-dirdiff'

" Run a diff on 2 blocks of text.
" Plug 'AndrewRadev/linediff.vim'

" Add spelling errors to the quickfix list
" (vim-ingo-library is a dependency).
" Plug 'inkarkat/vim-ingo-library' | Plug 'inkarkat/vim-SpellCheck'

" Briefly highlight which text was yanked.
" Plug 'machakann/vim-highlightedyank'

" Highlight which character to jump to when using horizontal
" movement keys.
" Plug 'unblevable/quick-scope'

" Modify * to also work with visual selections.
Plug 'nelstrom/vim-visual-star-search'

" Automatically clear search highlights after you move your cursor.
Plug 'haya14busa/is.vim'

" Handle multi-file find and replace.
" Plug 'mhinz/vim-grepper'

" Better display unwanted whitespace.
" Plug 'ntpeters/vim-better-whitespace'

" Toggle comments in various ways.
Plug 'tpope/vim-commentary'

" Automatically set 'shiftwidth' + 'expandtab' (indention) based
" on file type.
" Plug 'tpope/vim-sleuth'

" * A number of useful motions for the quickfix list, pasting and more.
" Plug 'tpope/vim-unimpaired'

" Drastically improve insert mode performance in files with folds.
" Plug 'Konfekt/FastFold'

Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'

" A git wrapper.
Plug 'tpope/vim-fugitive'
" Plug 'borissov/fugitive-bitbucketserver'
" Plug 'tommcdo/vim-fubitive'

" Show git file changes in the gutter.
" Plug 'mhinz/vim-signify'
Plug 'airblade/vim-gitgutter'
" Plug 'rhysd/git-messenger.vim'
" let g:git_messenger_no_default_mappings = v:true
" let g:git_messenger_close_on_cursor_moved = v:false
" let g:git_messenger_always_into_popup = v:false
" let g:git_messenger_into_popup_after_show = v:true
" let g:git_messenger_into_popup_after_show = v:false
" nnoremap <Leader>gm <Plug>(git-messenger-into-popup)
" nmap <Leader>gm <Plug>(git-messenger)

" * Dim paragraphs above and below the active paragraph.
" Plug 'junegunn/limelight.vim'

" * Distraction free writing by removing UI elements and centering
" everything.
" Plug 'junegunn/goyo.vim'

" A bunch of useful language related snippets (ultisnips is the engine).
" Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'

" * Automatically show Vim's complete menu while typing.
" Plug 'vim-scripts/AutoComplPop'

" Run test suites for various languages.
Plug 'janko/vim-test'
" Build and test dispatcher.
Plug 'tpope/vim-dispatch' "{{{
        let g:dispatch_no_maps = 1
"}}}
" Languages and file types.
" Plug 'cakebaker/scss-syntax.vim'
" Plug 'chr4/nginx.vim'
" Plug 'chrisbra/csv.vim'
" Plug 'ekalinin/dockerfile.vim'
" Plug 'elixir-editors/vim-elixir'
" Plug 'Glench/Vim-Jinja2-Syntax'
" Plug 'godlygeek/tabular' | Plug 'tpope/vim-markdown'
" Plug 'iamcco/markdown-preview.nvim', { 'do': 'cd app & yarn install' }
" Plug 'jvirtanen/vim-hcl'
" Plug 'lifepillar/pgsql.vim'
" Plug 'othree/html5.vim'
" Plug 'pangloss/vim-javascript'
" Plug 'PotatoesMaster/i3-vim-syntax'
" Plug 'stephpy/vim-yaml'
" Plug 'tmux-plugins/vim-tmux'
" Plug 'tpope/vim-git'
" Plug 'tpope/vim-liquid'
" Plug 'tpope/vim-rails'
" Plug 'vim-python/python-syntax'
" Plug 'vim-ruby/vim-ruby'
" Plug 'wgwoods/vim-systemd-syntax'

" Plug 'Shougo/deoplete.nvim'
" Plug 'roxma/nvim-yarp'
" Plug 'roxma/vim-hug-neovim-rpc'

Plug 'fatih/vim-go'

" Plug 'dense-analysis/ale'

"Plug 'itchyny/vim-cursorword'

" Toggle functions for quickfix and location list.
Plug 'milkypostman/vim-togglelist'

" LSP & Autocomplete {{{

Plug 'prabirshrestha/async.vim'
" Language Server Protocol.
Plug 'prabirshrestha/vim-lsp'
" Configurator for vim-lsp.
Plug 'mattn/vim-lsp-settings'
" Completion menu.
Plug 'prabirshrestha/asyncomplete.vim'
" Completion menu for vim-lsp.
Plug 'prabirshrestha/asyncomplete-lsp.vim'

let g:asyncomplete_auto_popup       = v:true
let g:asyncomplete_auto_completeopt = v:true

autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif
inoremap <expr> <Tab>   pumvisible() ? "<C-n>" : "<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "<C-p>" : "<S-Tab>"
inoremap <expr> <Cr>    pumvisible() ? "<C-y>" : "<Cr>"


" }}}

" Debug Adapter Protocol for vim.
Plug 'puremourning/vimspector'
" Document inspector.
Plug 'liuchengxu/vista.vim'

call plug#end()

" let g:fubitive_domain_pattern = 'stash\.msk\.avito\.ru'
" let g:fugitive_bitbucketservers_domains = ['stash.msk.avito.ru']
"  Color settings
" ---------------------

" non-break-space
set fillchars+=vert:Â 
" highlight VertSplit cterm=NONE ctermfg=Green ctermbg=NONE guibg=#000000 guifg=#000000
hi VertSplit gui=reverse

" Enable 24-bit true colors if your terminal supports it.
if (has("termguicolors"))
  set termguicolors
endif

" Enable syntax highlighting.
" syntax on
syntax on

" Set the color scheme.
" colorscheme gruvbox
" let g:gruvbox_transparent_bg = 1
let g:gruvbox_contrast_light = 'high'
let g:gruvbox_termcolors = 16
set background=light
" colorscheme gruvbox
" autocmd VimEnter * hi Normal ctermbg=NONE guibg=NONE
colorscheme humanoid

highlight cursorline ctermbg=White guibg=White
highlight cursorlinenr cterm=none gui=none
highlight label cterm=none gui=none
highlight function cterm=bold gui=bold ctermfg=16 guifg=#010000
highlight operator cterm=none gui=none ctermfg=16 guifg=#010000
highlight string ctermfg=29 guifg=#00875f
highlight keyword ctermfg=25 guifg=#005faf
highlight number ctermfg=124 guifg=#af0000
highlight float ctermfg=124 guifg=#af0000
highlight boolean ctermfg=32 guifg=#0087d7
highlight type ctermfg=131 guifg=#af5f5f

highlight link conditional label
highlight link goConditional label

highlight goTypeName ctermfg=168 guifg=#d75f5f
" highlight link goTypeName Label

" colorscheme two-firewatch
" colorscheme paper
" let g:solarized_contrast = "high"
" let g:solarized_bold = 1
" let g:solarized_termcolors = 256
" let g:solarized_degrade = 1
" set background=light
" colorscheme solarized

" Specific colorscheme settings (must come before setting your colorscheme).
" if !exists('g:gruvbox_contrast_light')
"   let g:gruvbox_contrast_light='hard'
" endif

" Specific colorscheme settings (must come after setting your colorscheme).
" if (g:colors_name == 'gruvbox')
"   if (&background == 'dark')
"      hi CursorLine guibg=#2a2f2a
"      hi Visual cterm=NONE ctermfg=NONE ctermbg=237 guibg=#3a4f3a
" "     hi IncSearch term=reverse cterm=reverse ctermfg=208 ctermbg=235 gui=reverse guifg=#fe8019 guibg=#282828
" "     hi Search    term=reverse cterm=reverse ctermfg=214 ctermbg=235 gui=reverse guifg=#fabd2f guibg=#282828
" "     hi IncSearch cterm=NONE ctermfg=0 ctermbg=70 guibg=#5fd700
"    else
"      hi Visual cterm=NONE ctermfg=NONE ctermbg=228 guibg=#f2e5bc
"      hi CursorLine cterm=NONE ctermfg=NONE ctermbg=228 guibg=#f2e5bc
"      hi ColorColumn cterm=NONE ctermfg=NONE ctermbg=228 guibg=#f2e5bc
"   endif
" endif

" Spelling mistakes will be colored up red.
hi SpellBad cterm=underline ctermfg=203 guifg=#ff5f5f
hi SpellLocal cterm=underline ctermfg=203 guifg=#ff5f5f
hi SpellRare cterm=underline ctermfg=203 guifg=#ff5f5f
hi SpellCap cterm=underline ctermfg=203 guifg=#ff5f5f

" TODO: compatibility with CtrlFS
" let s:matchid = 0
" highlight HlCurrentWord cterm=NONE ctermfg=NONE ctermbg=68 guibg=#4f3a3a
" function! HlCurrentWordFunc()
"         if s:matchid > 0
"             call matchdelete(s:matchid)
"             let s:matchid = 0
"         endif
"         let w = expand('<cword>')
"         if strlen(w) > 0
"                let s:matchid = matchadd('HlCurrentWord', '\V\C' . escape(w, '/\') . '')
"         endif
" endfunction
" augroup highlight_current_word
"   au!
"   au CursorHold * :call HlCurrentWordFunc()
" augroup END

" Status line
" ---------------------

" Heavily inspired by: 
" https://github.com/junegunn/dotfiles/blob/master/vimrc
function! s:statusline_expr()
  let mod = "%{&modified ? '[+] ' : !&modifiable ? '[-] ' : ''}"
  let ro  = "%{&readonly ? '[RO] ' : ''}"
  let ft  = "%{len(&filetype) ? '['.&filetype.'] ' : ''}"
  let fug = "%{exists('g:loaded_fugitive') ? fugitive#statusline() : ''}"
  let sep = ' %= '
  let pos = ' %-12(%l : %c%V%)'
  let pct = ' %P '
  " let fn  = '%{pathshorten(expand("%:."))}'
  let fn  = '%{expand("%:.")}'

  return '[%n:%{mode()}] '.fn.':%l %<'.mod.ro.ft.fug.sep.pos.'%*'.pct
endfunction

let &statusline = s:statusline_expr()

" Basic Settings
" ---------------------

" set mouse=a
" set colorcolumn=80

let mapleader=" "
let maplocalleader=" "

set lazyredraw
set updatetime=100
set autoindent
set autoread
set backspace=indent,eol,start
set backupdir=/tmp//,.
set clipboard=unnamed
set complete+=kspell
" set completeopt=menuone,longest
set completeopt=menuone,noinsert,noselect,preview
" set cursorline
set directory=/tmp//,.
set encoding=utf-8
set expandtab smarttab
set formatoptions=tcqrn1
set hidden
set hlsearch
set ignorecase
set incsearch
set laststatus=2
set matchpairs+=<:> " Use % to jump between pairs
set mmp=5000
set modelines=2
set mouse=n
set nocompatible
set noerrorbells visualbell t_vb=
set noshiftround
set nostartofline
set noswapfile
set number relativenumber
set regexpengine=1
set ruler
set scrolloff=3
set shiftwidth=8
set shortmess+=c
set showcmd
set showmatch
set showmode
set smartcase
set softtabstop=4
set nospell
set spelllang=en_us,ru_yo
set splitbelow
set splitright
set tabstop=8
set textwidth=0
set timeoutlen=1000
set ttimeout
set ttimeoutlen=0
set ttyfast
set undodir=/tmp
set undofile
set virtualedit=block
set whichwrap=b,s,<,>
set wildmenu
set wildmode=full
set nowrap
set listchars=tab:â¹\ ,space:â,eol:Â¬
set nolist

" Basic mappings
" ---------------------

" Command line.
nnoremap <Leader>; :
" cnoremap jk <C-c>
" cnoremap kj <C-c>
cnoremap jj <C-c>

" Exit from insert mode using the least used pair of letters.
" inoremap jk <C-c>
" inoremap kj <C-c>
inoremap jj <C-c>

" Seamlessly treat visual lines as actual lines when moving around.
noremap j gj
noremap k gk
noremap <Down> gj
noremap <Up> gk
inoremap <Down> <C-o>gj
inoremap <Up> <C-o>gk

" Navigate around splits with a single key combo.
nnoremap <C-l> <C-w><C-l>
nnoremap <C-h> <C-w><C-h>
nnoremap <C-k> <C-w><C-k>
nnoremap <C-j> <C-w><C-j>

tnoremap <C-l> <C-w><C-l>
tnoremap <C-h> <C-w><C-h>
tnoremap <C-k> <C-w><C-k>
tnoremap <C-j> <C-w><C-j>

augroup fern-custom
  autocmd! *
  autocmd FileType fern nnoremap <buffer> <C-l> <C-w><C-l>
  autocmd FileType fern nnoremap <buffer> <C-h> <C-w><C-h>
  autocmd FileType fern nnoremap <buffer> <C-k> <C-w><C-k>
  autocmd FileType fern nnoremap <buffer> <C-j> <C-w><C-j>
  autocmd FileType fern nnoremap <buffer> . <Plug>(fern-action-hidden)
augroup END

nnoremap <silent> <Leader>qq :quit<CR>
nnoremap <silent> <Leader>qw :wq<CR>
nnoremap <silent> <Leader>qb :bdelete<CR>
nnoremap <silent> <Leader>qc :cclose<CR>
nnoremap <silent> <Leader>ql :lclose<CR>
nnoremap <silent> <Leader>qp :pclose<CR>
nnoremap <silent> <Leader>qa :qall<CR>
nnoremap <silent> <Leader>qe :qall!<CR>

nnoremap <silent> <Leader>oO :only<CR>
nnoremap <silent> <Leader>oo :MaximizerToggle!<CR>

nnoremap <Leader>w :write<cr>

cnoremap <C-a> <Home>
cnoremap <C-e> <End>

nnoremap <silent> ]q :cnext<CR>
nnoremap <silent> [q :cprevious<CR>

" Avoid unintentional switches to Ex mode.
nmap Q q

" Repeat last macro if in a normal buffer.
nnoremap <expr> <CR> empty(&buftype) ? '@@' : '<CR>'
nnoremap <A-j> k

" Command line. Pretty useful with Caps Lock as Esc.
" nnoremap <Tab> :

" Clear search highlights.
nnoremap <silent> <Leader>/ :let @/=''<CR>

" Open last buffer.
nnoremap <silent> <Leader><Leader> <C-^>

" Cycle through splits.
" nnoremap <S-Tab> <C-w>w

" Press * to search for the term under the cursor or a visual selection and
" then press a key below to replace all instances of it in the current file.
nnoremap <Leader>r :%s///g<Left><Left>
nnoremap <Leader>rc :%s///gc<Left><Left><Left>

" The same as above but instead of acting on the whole file it will be
" restricted to the previously visually selected range. You can do that by
" pressing *, visually selecting the range you want it to apply to and then
" press a key below to replace all instances of it in the current selection.
xnoremap <Leader>r :s///g<Left><Left>
xnoremap <Leader>rc :s///gc<Left><Left><Left>

" Type a replacement term and press . to repeat the replacement again. Useful
" for replacing a few instances of the term (comparable to multiple cursors).
nnoremap <silent> cs :let @/='\<'.expand('<cword>').'\>'<CR>cgn
xnoremap <silent> cs "sy:let @/=@s<CR>cgn

" As above, only easier.
nnoremap c* *Ncgn

" Format paragraph (selected or not) to 80 character lines.
" nnoremap <Leader>g gqap
" xnoremap <Leader>g gqa

" Prevent x from overriding what's in the clipboard.
noremap x "_x
noremap X "_x

" Prevent selecting and pasting from overwriting what you originally copied.
xnoremap p pgvy

" Keep cursor at the bottom of the visual selection after you yank it.
vmap y ygv<Esc>

" Edit Vim config file in a new tab.
nnoremap <Leader>ve :edit $MYVIMRC<CR>

" Source Vim config file.
nnoremap <Leader>vr :source $MYVIMRC<CR>

" Install plugins.
nnoremap <leader>vi :PlugInstall<cr>

" Update plugins.
nnoremap <leader>vu :PlugUpdate<cr>

" Toggle spell check.
nnoremap <Leader>os :setlocal spell!<CR>

" Toggle relative line numbers and regular line numbers.
nnoremap <Leader>or :setlocal relativenumber!<CR>

" Toggle visually showing all whitespace characters.
nnoremap <Leader>ol :setlocal list!<CR>

" Toggle nowrap.
nnoremap <Leader>ow :setlocal nowrap!<CR>

" function ToggleColorColumn() {

" }
" nnoremap <Leader>oc :setlocal nowrap!<CR>

" Automatically fix the last misspelled word and jump back to where you were.
"   Taken from this talk: https://www.youtube.com/watch?v=lwD8G1P52Sk
nnoremap <leader>sp :normal! mz[s1z=`z<CR>
" noremap <F7> :set list!<CR>
" inoremap <F7> <C-o>:set list!<CR>
" cnoremap <F7> <C-c>:set list!<CR>

" Move 1 more lines up or down in normal and visual selection modes.
" nnoremap K :m .-2<CR>==
" nnoremap J :m .+1<CR>==
vnoremap K :m '<-2<CR>gv=gv
vnoremap J :m '>+1<CR>gv=gv

" Convert the selected text's title case using the external tcc script.
"   Requires: https://github.com/nickjj/title-case-converter
" vnoremap <Leader>tc c<C-r>=system('tcc', getreg('"'))[:-2]<CR>

" Navigate the complete menu items like CTRL+n / CTRL+p would.
" inoremap <expr> <Down> pumvisible() ? "<C-n>" :"<Down>"
" inoremap <expr> <Up> pumvisible() ? "<C-p>" : "<Up>"

" Select the complete menu item like CTRL+y would.
" inoremap <expr> <Right> pumvisible() ? "<C-y>" : "<Right>"
" inoremap <expr> <CR> pumvisible() ? "<C-y>" :"<CR>"
" inoremap <expr> <Tab> pumvisible() ? "<C-y>" :"<Tab>"


" Cancel the complete menu item like CTRL+e would.
" inoremap <expr> <Left> pumvisible() ? "<C-e>" : "<Left>"

" Basic autocommands
" ---------------------

" Auto-resize splits when Vim gets resized.
autocmd VimResized * wincmd =

" Update a buffer's contents on focus if it changed outside of Vim.
au FocusGained,BufEnter * :checktime

" Unset paste on InsertLeave.
autocmd InsertLeave * silent! set nopaste

" Make sure all types of requirements.txt files get syntax highlighting.
autocmd BufNewFile,BufRead requirements*.txt set ft=python

" Make sure .aliases, .bash_aliases and similar files get syntax highlighting.
autocmd BufNewFile,BufRead .*aliases set ft=sh

" Ensure tabs don't get converted to spaces in Makefiles.
autocmd FileType make setlocal noexpandtab

" Only show the cursor line in the active buffer.
" augroup CursorLineForCurrentWindow
"     au!
"     au VimEnter,WinEnter,BufWinEnter * setlocal cursorline
"     au WinLeave * setlocal nocursorline
" augroup END

" Mappings to make Vim more friendly towards presenting slides.
" autocmd BufNewFile,BufRead *.vpm call SetVimPresentationMode()
" function SetVimPresentationMode()
"   nnoremap <buffer> <Right> :n<CR>
"   nnoremap <buffer> <Left> :N<CR>
" 
"   if !exists('#goyo')
"     Goyo
"   endif
" endfunction

" Basic commands
" ---------------------

" Add all TODO items to the quickfix list relative to where you opened Vim.
function! s:todo() abort
  let entries = []
  for cmd in ['git grep -niIw -e TODO -e FIXME 2> /dev/null',
            \ 'grep -rniIw -e TODO -e FIXME . 2> /dev/null']
    let lines = split(system(cmd), '\n')
    if v:shell_error != 0 | continue | endif
    for line in lines
      let [fname, lno, text] = matchlist(line, '^\([^:]*\):\([^:]*\):\(.*\)')[1:3]
      call add(entries, { 'filename': fname, 'lnum': lno, 'text': text })
    endfor
    break
  endfor

  if !empty(entries)
    call setqflist(entries)
    copen
  endif
endfunction

command! Todo call s:todo()

" Profile Vim by running this command once to start it and again to stop it.
function! s:profile(bang)
  if a:bang
    profile pause
    noautocmd qall
  else
    profile start /tmp/profile.log
    profile func *
    profile file *
  endif
endfunction

command! -bang Profile call s:profile(<bang>0)

" Plugin settings, mappings and autocommands
" ---------------------

" junegunn/fzf.vim
" .....................

let $FZF_DEFAULT_OPTS = '--bind ctrl-a:select-all --reverse'

let g:fzf_layout = { 'down': '35%' }
let g:fzf_layout = { 'window': 'enew' }
let g:fzf_preview_window = ['up:right:50%', 'ctrl-/']
let g:fzf_action = {
        \ 'ctrl-t': 'tab split',
        \ 'ctrl-s': 'split',
        \ 'ctrl-v': 'vsplit',
        \ 'ctrl-y': {lines -> setreg('*', join(lines, "\n"))}}
let g:fzf_colors =
        \ { 'fg':      ['fg', 'Normal'],
        \ 'bg':      ['bg', 'Normal'],
        \ 'hl':      ['fg', 'Comment'],
        \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
        \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
        \ 'hl+':     ['fg', 'Statement'],
        \ 'info':    ['fg', 'PreProc'],
        \ 'border':  ['fg', 'Ignore'],
        \ 'prompt':  ['fg', 'Conditional'],
        \ 'pointer': ['fg', 'Exception'],
        \ 'marker':  ['fg', 'Keyword'],
        \ 'spinner': ['fg', 'Label'],
        \ 'header':  ['fg', 'Comment'] }


" Launch fzf with CTRL+P.
" ?
noremap <silent> <Leader>ff :Files<CR>

" Map a few common things to do with FZF.
nnoremap <silent> <Leader><Enter> :Buffers<CR>
nnoremap <silent> <Leader>fl :Lines<CR>
nnoremap <silent> <Leader>fg :Rg<CR>

" Allow passing optional flags into the Rg command.
"   Example: :Rg myterm -g '*.md'
" command! -bang -nargs=* Rg
"   \ call fzf#vim#grep(
"   \ "rg --column --line-number --no-heading --color=always --smart-case " .
"   \ <q-args>, 1, fzf#vim#with_preview(), <bang>0)
" command! -bang -nargs=* Rg
"         \ call fzf#vim#grep(
"         \   'rg --column --line-number --no-heading --color=always --smart-case -- '.shellescape(<q-args>), 1,
"         \   fzf#vim#with_preview(), <bang>0)

command! -bang -nargs=? -complete=dir Files
        \ call fzf#vim#files(<q-args>, fzf#vim#with_preview({'options': ['--layout=reverse', '--info=inline']}), <bang>0)

function! RipgrepFzf(query, fullscreen)
        let command_fmt = 'rg --no-column --line-number --no-heading --color=always --smart-case -- %s || true'
        let initial_command = printf(command_fmt, shellescape(a:query))
        let reload_command = printf(command_fmt, '{q}')
        let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
        call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
endfunction

command! -nargs=* -bang Rg call RipgrepFzf(<q-args>, <bang>0)




" dyng/ctrlsf.vim
" .....................

let g:ctrlsf_context = '-B 2 -A 1'
" let g:ctrlsf_auto_preview = 1
let g:ctrlsf_compact_winsize = '30%'
let g:ctrlsf_winsize = '30%'
let g:ctrlsf_auto_focus = { "at" : "start" }

nmap <leader>sf <Plug>CtrlSFCCwordExec
" :CtrlSF<CR>

" lambdalisue/fern.vim
" .....................

" Disable netrw.
let g:loaded_netrw  = 1
let g:loaded_netrwPlugin = 1
let g:loaded_netrwSettings = 1
let g:loaded_netrwFileHandlers = 1

" augroup my-fern-hijack
"   autocmd!
"   autocmd BufEnter * ++nested call s:hijack_directory()
" augroup END

" function! s:hijack_directory() abort
"   let path = expand('%:p')
"   if !isdirectory(path)
"     return
"   endif
"   bwipeout %
"   execute printf('Fern %s', fnameescape(path))
" endfunction

" Custom settings and mappings.
" let g:fern#disable_default_mappings = 1

" Use symbols.
let g:fern#renderer = "nerdfont"

noremap <silent> <Leader>fd :Fern . -drawer -reveal=% -toggle -width=25<CR>
noremap <silent> <Leader>fD <Plug>(fern-action-reveal)
" noremap <silent> <Leader>fd :Fern . -drawer -reveal=% -toggle -width=30<CR><C-w>=

function! FernInit() abort
  setlocal nonumber
  setlocal norelativenumber
  nmap <buffer><expr>
        \ <Plug>(fern-my-open-expand-collapse)
        \ fern#smart#leaf(
        \   "\<Plug>(fern-action-open:select)",
        \   "\<Plug>(fern-action-expand)",
        \   "\<Plug>(fern-action-collapse)",
        \ )
  nmap <buffer> <CR> <Plug>(fern-my-open-expand-collapse)<Esc><Bar>:FernDo close<CR>
  nmap <buffer> <2-LeftMouse> <Plug>(fern-my-open-expand-collapse)
  nmap <buffer> n <Plug>(fern-action-new-path)
  nmap <buffer> d <Plug>(fern-action-remove)
  nmap <buffer> m <Plug>(fern-action-move)
  nmap <buffer> M <Plug>(fern-action-rename)
  " nmap <buffer> h <Plug>(fern-action-hidden-toggle)
  nmap <buffer> r <Plug>(fern-action-reload)
  " nmap <buffer> k <Plug>(fern-action-mark)
  " nmap <buffer> K <Plug>(fern-action-mark-children:leaf)
  nmap <buffer> b <Plug>(fern-action-open:split)
  nmap <buffer> v <Plug>(fern-action-open:vsplit)
  nmap <buffer><nowait> < <Plug>(fern-action-leave)
  nmap <buffer><nowait> > <Plug>(fern-action-enter)
endfunction

augroup FernGroup
  autocmd!
  autocmd FileType fern call FernInit()
augroup END

" unblevable/quick-scope
" .....................

" Trigger a highlight in the appropriate direction when pressing these keys.
" let g:qs_highlight_on_keys=['f', 'F', 't', 'T']

" Only underline the highlights instead of using custom colors.
" highlight QuickScopePrimary gui=underline cterm=underline
" highlight QuickScopeSecondary gui=underline cterm=underline

" mhinz/vim-grepper
" .....................

" let g:grepper={}
" let g:grepper.tools=["rg"]

" xmap gr <plug>(GrepperOperator)

" " After searching for text, press this mapping to do a project wide find and
" " replace. It's similar to <leader>r except this one applies to all matches
" " across all files instead of just the current file.
" nnoremap <Leader>R
"   \ :let @s='\<'.expand('<cword>').'\>'<CR>
"   \ :Grepper -cword -noprompt<CR>
"   \ :cfdo %s/<C-r>s//g \| update
"   \<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>

" " The same as above except it works with a visual selection.
" xmap <Leader>R
"     \ "sy
"     \ gvgr
"     \ :cfdo %s/<C-r>s//g \| update
"      \<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>

" ntpeters/vim-better-whitespace
" .....................

" let g:strip_whitespace_confirm=0
" let g:strip_whitelines_at_eof=1
" let g:strip_whitespace_on_save=1

" Konfekt/FastFold
" .....................

let g:fastfold_savehook=0
let g:fastfold_fold_command_suffixes=[]

" junegunn/limelight.vim
" .....................

let g:limelight_conceal_ctermfg=244

" iamcco/markdown-preview.nvim
" .....................

" let g:mkdp_auto_close=0
" let g:mkdp_refresh_slow=1
" let g:mkdp_markdown_css=fnameescape($HOME).'/.local/lib/github-markdown-css/github-markdown.css'

" SirVer/ultisnips
" .....................

" let g:UltiSnipsJumpForwardTrigger="<tab>"
" let g:UltiSnipsJumpBackwardTrigger="<s-tab>"

" janko/vim-test
" .....................

" ij has('nvim')
"   let test#strategy='neovim'
" else
"   let test#strategy='vimterminal'
" endif

" let test#python#pytest#executable='docker-compose exec web py.test'

" let test#ruby#rails#executable='docker-compose exec -e RAILS_ENV=test webpacker rails test'

" let test#elixir#exunit#executable='docker-compose exec -e MIX_ENV=test web mix test'
" let test#strategy = 'asyncrun_background'
" let test#strategy='vimterminal'
let test#strategy='dispatch'

nmap <silent> <Leader>tn :TestNearest<CR>
nmap <silent> <Leader>tf :TestFile<CR>
nmap <silent> <Leader>ts :TestSuite<CR>
nmap <silent> <Leader>tl :TestLast<CR>
nmap <silent> <Leader>tv :TestVisit<CR>

" fatih/vim-go
" .....................

let g:go_gopls_enabled = 1 " enable description in command line
let g:go_code_completion_enabled = 0
let g:go_def_mapping_enabled = 0
let g:go_diagnostics_enabled = 0

let g:go_highlight_build_constraints = 1
let g:go_highlight_extra_types = 1
let g:go_highlight_fields = 1
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_operators = 1
let g:go_highlight_structs = 1
let g:go_highlight_types = 1

let g:go_auto_type_info = 1


" ale
" .....................

" let g:ale_completion_enabled = 1
" set omnifunc=ale#completion#OmniFunc
let g:ale_linters = {
  \ 'go': ['gobuild', 'gofmt', 'golangci-lint', 'gometalinter', 'gopls', 'gosimple', 'gotype', 'govet', 'revive'],
  \}

let g:ale_completion_symbols = {
  \ 'text': 'î',
  \ 'method': 'ï§',
  \ 'function': 'ï',
  \ 'constructor': 'ï²',
  \ 'field': 'ï­',
  \ 'variable': 'ï¡',
  \ 'class': 'ï¨',
  \ 'interface': 'ï ',
  \ 'module': 'ï²',
  \ 'property': 'ï­',
  \ 'unit': 'unit',
  \ 'value': 'val',
  \ 'enum': 'ï ',
  \ 'keyword': 'keyword',
  \ 'snippet': 'î',
  \ 'color': 'color',
  \ 'file': 'ï­',
  \ 'reference': 'ref',
  \ 'folder': 'î¿',
  \ 'enum member': 'ï²',
  \ 'constant': 'ï¡',
  \ 'struct': 'î',
  \ 'event': 'event',
  \ 'operator': 'ï­',
  \ 'type_parameter': 'type param',
  \ '<default>': 'v'
  \ }

" justinmk/vim-sneak
" .....................

let g:sneak#use_ic_scs = 1
let g:sneak#label = 1

" prabirshrestha/vim-lsp
" .....................

let g:lsp_diagnostics_float_cursor = 1
let g:lsp_diagnostics_echo_cursor = 1
let g:lsp_diagnostics_enabled = 1
let g:lsp_preview_float = 1
let g:lsp_hover_conceal = 0

function! s:on_lsp_buffer_enabled() abort
    " setlocal omnifunc=lsp#complete
    setlocal signcolumn=yes
    if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
    nmap <buffer> gd <plug>(lsp-definition)
    nmap <buffer> gs <plug>(lsp-document-symbol-search)
    nmap <buffer> gS <plug>(lsp-workspace-symbol-search)
    nmap <buffer> gr <plug>(lsp-references)
    nmap <buffer> gi <plug>(lsp-implementation)
    nmap <buffer> gt <plug>(lsp-type-definition)
    nmap <buffer> <leader>er <plug>(lsp-rename)
    nmap <buffer> [g <plug>(lsp-previous-diagnostic)
    nmap <buffer> ]g <plug>(lsp-next-diagnostic)
    nmap <buffer> K <plug>(lsp-hover)
    inoremap <buffer> <expr><c-f> lsp#scroll(+4)
    inoremap <buffer> <expr><c-d> lsp#scroll(-4)

    let g:lsp_format_sync_timeout = 1000
    autocmd! BufWritePre *.rs,*.go call execute('LspDocumentFormatSync')
    
    " refer to doc to add more commands
endfunction

augroup lsp_install
    au!
    " call s:on_lsp_buffer_enabled only for languages that has the server registered.
    autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END

" liuchengxu/vista.vim
" .....................

let g:vista_close_on_jump = 1
let g:vista_disable_statusline = 1
let g:vista_highlight_whole_line = 1
let g:vista_executive_for = {
        \ 'go': 'vim_lsp',
        \ 'python': 'vim_lsp',
        \ 'vim': 'vim_lsp',
        \ }

noremap <silent> <Leader>fs :Vista!!<CR>

" prabirshrestha/asyncomplete-lsp.vim
"
" autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif

" milkypostman/vim-togglelist
" .....................

nnoremap <script> <silent> <leader>i :call ToggleLocationList()<CR>
nnoremap <script> <silent> <leader>c :call ToggleQuickfixList()<CR>

" puremourning/vimspector
" .....................

let g:vimspector_base_dir = expand( '$HOME/.vim/vimspector-config' )
function! GotoWindow(id)
  :call win_gotoid(a:id)
endfun
function! AddToWatch()
  let word = expand("<cexpr>")
  call vimspector#AddWatch(word)
endfunction
let g:vimspector_sidebar_width = 60
nnoremap <leader>da :call vimspector#Launch()<CR>
nnoremap <leader>dc :call GotoWindow(g:vimspector_session_windows.code)<CR>
nnoremap <leader>dv :call GotoWindow(g:vimspector_session_windows.variables)<CR>
nnoremap <leader>dw :call GotoWindow(g:vimspector_session_windows.watches)<CR>
nnoremap <leader>ds :call GotoWindow(g:vimspector_session_windows.stack_trace)<CR>
nnoremap <leader>do :call GotoWindow(g:vimspector_session_windows.output)<CR>
nnoremap <leader>di :call AddToWatch()<CR>
nnoremap <leader>dx :call vimspector#Reset()<CR>
nnoremap <leader>dX :call vimspector#ClearBreakpoints()<CR>
" nnoremap <S-k> :call vimspector#StepOut()<CR>
" nnoremap <S-l> :call vimspector#StepInto()<CR>
" nnoremap <S-j> :call vimspector#StepOver()<CR>
nnoremap <leader>d_ :call vimspector#Restart()<CR>
nnoremap <leader>dn :call vimspector#Continue()<CR>
nnoremap <leader>drc :call vimspector#RunToCursor()<CR>
nnoremap <leader>dh :call vimspector#ToggleBreakpoint()<CR>
nnoremap <leader>de :call vimspector#ToggleConditionalBreakpoint()<CR>
let g:vimspector_sign_priority = {
  \    'vimspectorBP':         998,
  \    'vimspectorBPCond':     997,
  \    'vimspectorBPDisabled': 996,
  \    'vimspectorPC':         999,
  \ }

" tpope/vim-dispatch
" .....................

" tpope/vim-fugitive
"
nnoremap <Leader>vb :Gblame<CR>
nnoremap <Leader>vd :Gdiffsplit<CR>
nnoremap <Leader>vD :Git difftool<CR>
nnoremap <Leader>vg :Git<CR>

" prabirshrestha/asyncomplete-lsp.vim
" ---
" vim:foldmethod=marker
